name: STG (development) - Build, Infra & Migrations via PR

on:
  pull_request:
    branches: ["main"]
    types: [opened, synchronize, reopened]
    paths:
      - "services/**"
      - "infra/**"
      - "migrations/**"
      - ".github/workflows/dev-pr-stg-apply.yml"

permissions:
  id-token: write
  contents: read

concurrency:
  group: pr-stg-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  # -------- Naming / imagens --------
  ECR_REGISTRY: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  TAG_PREFIX: pr-${{ github.event.pull_request.number }}
  IMAGE_TAG_INTER:  pr-${{ github.event.pull_request.number }}-inter
  IMAGE_TAG_AGENT:  pr-${{ github.event.pull_request.number }}-agent
  IMAGE_TAG_PRINC:  pr-${{ github.event.pull_request.number }}-principal

  # -------- NAME PREFIX --------
  NAME_PREFIX: ura-chatbot-ia-pr-${{ github.event.pull_request.number }}

  # -------- Terraform TF_VAR_* --------
  TF_VAR_region: ${{ vars.AWS_REGION }}
  TF_VAR_name_prefix: ura-chatbot-ia-pr-${{ github.event.pull_request.number }}
  TF_VAR_account_id: ${{ vars.AWS_ACCOUNT_ID }}
  TF_VAR_ecr_repository: ${{ vars.ECR_REPOSITORY }}
  TF_VAR_image_tag_api_intermediaria: pr-${{ github.event.pull_request.number }}-inter
  TF_VAR_image_tag_api_agente:        pr-${{ github.event.pull_request.number }}-agent
  TF_VAR_image_tag_api_principal:     pr-${{ github.event.pull_request.number }}-principal
  TF_VAR_rds_db_name: app_stg
  TF_VAR_APP_CRM_URL: ${{ vars.APP_CRM_URL }}

  # -------- Diretórios --------
  SERVICE_INTER_PATH: services/api-intermediaria
  SERVICE_AGENT_PATH: services/api-agente
  SERVICE_PRINC_PATH: services/api-principal
  INFRA_DIR: infra
  MIGRATIONS_DIR: migrations/sql

jobs:
  build-infra-migrate:
    name: Build images → Terraform apply → Flyway migrate
    runs-on: ubuntu-latest
    environment: development
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_STG }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Buildx (docker-container)
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver: docker-container

      # ---------- Build & Push ----------
      - name: Build & Push - api-intermediaria
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_INTER_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_INTER }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-inter
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-inter,mode=max
          build-args: |
            RUN_TESTS=false

      - name: Build & Push - api-agente
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_AGENT_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_AGENT }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-agent
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-agent,mode=max
          build-args: |
            RUN_TESTS=false

      - name: Build & Push - api-principal
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_PRINC_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_PRINC }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-principal
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-principal,mode=max
          build-args: |
            RUN_TESTS=false

      # ---------- Terraform ----------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8
          terraform_wrapper: false

      - name: Terraform CLI defaults
        run: |
          echo 'TF_CLI_ARGS=-no-color' >> $GITHUB_ENV
          echo 'TF_CLI_ARGS_plan=-input=false -lock-timeout=5m -parallelism=10' >> $GITHUB_ENV
          echo 'TF_CLI_ARGS_apply=-input=false -lock-timeout=5m -parallelism=10' >> $GITHUB_ENV

      - name: Terraform fmt (write)
        working-directory: ${{ env.INFRA_DIR }}
        run: terraform fmt -recursive

      - name: Terraform fmt (check)
        working-directory: ${{ env.INFRA_DIR }}
        run: terraform fmt -check -diff -recursive

      - name: Terraform Init (backend S3)
        working-directory: ${{ env.INFRA_DIR }}
        run: |
          terraform init -input=false -upgrade -reconfigure \
            -backend-config="bucket=${{ vars.TF_STATE_BUCKET }}" \
            -backend-config="key=apprunner/pr-${{ github.event.pull_request.number }}/terraform.tfstate" \
            -backend-config="region=${{ vars.AWS_REGION }}"

      - name: Export TF VARs (sensitive)
        run: |
          echo "TF_VAR_OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_APP_CRM_ACESS_TOKEN=${{ secrets.APP_CRM_ACESS_TOKEN_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_API_PRINCIPAL_API_KEY=${{ secrets.API_PRINCIPAL_API_KEY_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_API_PRINCIPAL_SECRET_KEY=${{ secrets.API_PRINCIPAL_SECRET_KEY_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_WHASTAPP_CLIENT_TOKEN=${{ secrets.WHASTAPP_CLIENT_TOKEN_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_WHASTAPP_INSTANCE_ID=${{ secrets.WHASTAPP_INSTANCE_ID_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_WHASTAPP_TOKEN=${{ secrets.WHASTAPP_TOKEN_STG }}" >> $GITHUB_ENV
          echo "TF_VAR_rds_password=" >> $GITHUB_ENV

      - name: Terraform validate
        working-directory: ${{ env.INFRA_DIR }}
        run: terraform validate

      - name: Ensure RDS service-linked role
        run: |
          set -euo pipefail
          aws iam get-role --role-name "AWSServiceRoleForRDS" >/dev/null 2>&1 || \
          aws iam create-service-linked-role --aws-service-name "rds.amazonaws.com"

      # ---------- Imports idempotentes (ajustado p/ IAM novas) ----------
      - name: Terraform imports (idempotente, verificado)
        working-directory: ${{ env.INFRA_DIR }}
        env:
          NAME_PREFIX: ${{ env.NAME_PREFIX }}
          AWS_REGION:  ${{ vars.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          set -x

          echo "----- STATE (antes) -----"
          terraform state list || true

          in_state() { terraform state show "$1" >/dev/null 2>&1; }
          must_exist_in_state() {
            local addr="$1"
            in_state "$addr" || { echo "::error::$addr não foi importado (ausente no state)"; exit 1; }
          }

          # ---------- SQS (pré-existente) ----------
          SQS_URL="https://sqs.${AWS_REGION}.amazonaws.com/${AWS_ACCOUNT_ID}/entradas.fifo"
          if ! in_state aws_sqs_queue.fifo; then
            aws sqs get-queue-attributes --queue-url "$SQS_URL" --attribute-names QueueArn >/dev/null
            terraform import aws_sqs_queue.fifo "$SQS_URL"
          fi
          must_exist_in_state aws_sqs_queue.fifo

          # ---------- DynamoDB (pré-existente) ----------
          CTX_TABLE="contexto_entity_leadflow"
          OUTRO_TABLE="outro_contato_entity_leadflow"

          if ! in_state aws_dynamodb_table.contexto; then
            aws dynamodb describe-table --table-name "$CTX_TABLE" >/dev/null
            terraform import aws_dynamodb_table.contexto "$CTX_TABLE"
          fi
          must_exist_in_state aws_dynamodb_table.contexto

          if ! in_state aws_dynamodb_table.outro_contato; then
            aws dynamodb describe-table --table-name "$OUTRO_TABLE" >/dev/null
            terraform import aws_dynamodb_table.outro_contato "$OUTRO_TABLE"
          fi
          must_exist_in_state aws_dynamodb_table.outro_contato

          # ---------- RDS Subnet Group (pré-existente) ----------
          SUBNET_GRP="${NAME_PREFIX}-mysql-subnets"
          if ! in_state aws_db_subnet_group.this; then
            aws rds describe-db-subnet-groups --db-subnet-group-name "$SUBNET_GRP" >/dev/null
            terraform import aws_db_subnet_group.this "$SUBNET_GRP"
          fi
          must_exist_in_state aws_db_subnet_group.this

          # ---------- Security Group (pré-existente) ----------
          SG_ID="sg-0c54eef38b3a9e9c1"  # ajuste se necessário
          if ! in_state aws_security_group.mysql; then
            aws ec2 describe-security-groups --group-ids "$SG_ID" >/dev/null
            terraform import aws_security_group.mysql "$SG_ID"
          fi
          must_exist_in_state aws_security_group.mysql

          # ---------- RDS Instance (pré-existente) ----------
          DB_ID="${NAME_PREFIX}-mysql"
          if ! in_state aws_db_instance.mysql; then
            aws rds describe-db-instances --db-instance-identifier "$DB_ID" >/dev/null
            terraform import aws_db_instance.mysql "$DB_ID"
          fi
          must_exist_in_state aws_db_instance.mysql

          # ---------- IAM Roles (NOVAS → importar se existirem; senão, criar no apply) ----------
          ROLE_ACCESS_NAME="${NAME_PREFIX}-apprunner-access-role"
          if ! in_state aws_iam_role.apprunner_access_role; then
            if aws iam get-role --role-name "$ROLE_ACCESS_NAME" >/dev/null 2>&1; then
              terraform import aws_iam_role.apprunner_access_role "$ROLE_ACCESS_NAME"
            else
              echo "IAM role $ROLE_ACCESS_NAME ainda não existe; será criada pelo apply."
            fi
          fi

          ROLE_INSTANCE_NAME="${NAME_PREFIX}-apprunner-instance-role"
          if ! in_state aws_iam_role.apprunner_instance_role; then
            if aws iam get-role --role-name "$ROLE_INSTANCE_NAME" >/dev/null 2>&1; then
              terraform import aws_iam_role.apprunner_instance_role "$ROLE_INSTANCE_NAME"
            else
              echo "IAM role $ROLE_INSTANCE_NAME ainda não existe; será criada pelo apply."
            fi
          fi

          # ---------- IAM Policies (NOVAS → importar se existirem; senão, criar no apply) ----------
          POLICY_NAME_ACCESS="${NAME_PREFIX}-apprunner-access-ecr"
          POLICY_ARN_ACCESS=$(aws iam list-policies --scope Local \
            --query "Policies[?PolicyName=='${POLICY_NAME_ACCESS}'].Arn" --output text || true)
          if [ -n "${POLICY_ARN_ACCESS}" ] && ! in_state aws_iam_policy.apprunner_access_ecr; then
            terraform import aws_iam_policy.apprunner_access_ecr "${POLICY_ARN_ACCESS}"
          else
            echo "Policy ${POLICY_NAME_ACCESS} inexistente (ainda) ou já no state; apply cuidará."
          fi

          POLICY_NAME_INSTANCE="${NAME_PREFIX}-apprunner-policy"
          POLICY_ARN_INSTANCE=$(aws iam list-policies --scope Local \
            --query "Policies[?PolicyName=='${POLICY_NAME_INSTANCE}'].Arn" --output text || true)
          if [ -n "${POLICY_ARN_INSTANCE}" ] && ! in_state aws_iam_policy.apprunner_policy; then
            terraform import aws_iam_policy.apprunner_policy "${POLICY_ARN_INSTANCE}"
          else
            echo "Policy ${POLICY_NAME_INSTANCE} inexistente (ainda) ou já no state; apply cuidará."
          fi

          # ---------- Secrets Manager (pré-existentes) ----------
          import_secret () {
            local addr="$1"; local name="$2"
            if ! in_state "$addr"; then
              aws secretsmanager describe-secret --secret-id "$name" >/dev/null
              terraform import "$addr" "$name"
            fi
            must_exist_in_state "$addr"
          }

          # cred composto (Flyway)
          if ! in_state aws_secretsmanager_secret.db_app_creds; then
            aws secretsmanager describe-secret --secret-id "/${NAME_PREFIX}/db-app-creds" >/dev/null
            terraform import aws_secretsmanager_secret.db_app_creds "/${NAME_PREFIX}/db-app-creds"
          fi
          must_exist_in_state aws_secretsmanager_secret.db_app_creds

          import_secret aws_secretsmanager_secret.url_bd                  "/${NAME_PREFIX}/URL_BD"
          import_secret aws_secretsmanager_secret.user_bd                 "/${NAME_PREFIX}/USER_BD"
          import_secret aws_secretsmanager_secret.password_bd             "/${NAME_PREFIX}/PASSWORD_BD"
          import_secret aws_secretsmanager_secret.database_url            "/${NAME_PREFIX}/DATABASE_URL"
          import_secret aws_secretsmanager_secret.openai_api_key          "/${NAME_PREFIX}/OPENAI_API_KEY"
          import_secret aws_secretsmanager_secret.app_crm_acess_token     "/${NAME_PREFIX}/APP_CRM_ACESS_TOKEN"
          import_secret aws_secretsmanager_secret.api_principal_api_key   "/${NAME_PREFIX}/API_PRINCIPAL_API_KEY"
          import_secret aws_secretsmanager_secret.api_principal_secret_key "/${NAME_PREFIX}/API_PRINCIPAL_SECRET_KEY"
          import_secret aws_secretsmanager_secret.whatsapp_client_token   "/${NAME_PREFIX}/WHASTAPP_CLIENT_TOKEN"
          import_secret aws_secretsmanager_secret.whatsapp_instance_id    "/${NAME_PREFIX}/WHASTAPP_INSTANCE_ID"
          import_secret aws_secretsmanager_secret.whatsapp_token          "/${NAME_PREFIX}/WHASTAPP_TOKEN"

          echo "----- STATE (depois) -----"
          terraform state list || true

      - name: Terraform plan
        working-directory: ${{ env.INFRA_DIR }}
        run: terraform plan -out=tfplan

      - name: Terraform apply
        working-directory: ${{ env.INFRA_DIR }}
        run: terraform apply -auto-approve tfplan

      # ---------- Flyway ----------
      - name: Install tools (jq)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Read DB creds from Secrets Manager
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "/${{ env.NAME_PREFIX }}/db-app-creds" \
            --query SecretString --output text)
          echo "FLYWAY_URL=$(echo "$SECRET_JSON" | jq -r .jdbc_url)" >> $GITHUB_ENV
          echo "FLYWAY_USER=$(echo "$SECRET_JSON" | jq -r .username)" >> $GITHUB_ENV
          echo "FLYWAY_PASSWORD=$(echo "$SECRET_JSON" | jq -r .password)" >> $GITHUB_ENV

      - name: Run Flyway migrate (Docker)
        working-directory: ${{ env.MIGRATIONS_DIR }}/..
        run: |
          docker run --rm \
            -v "$PWD/sql:/flyway/sql" \
            flyway/flyway:latest \
            -url="${FLYWAY_URL}" \
            -user="${FLYWAY_USER}" \
            -password="${FLYWAY_PASSWORD}" \
            -connectRetries=30 \
            migrate
