name: STG (development) - Build, Infra & Migrations via PR

on:
  pull_request:
    branches: ["main"]
    types: [opened, synchronize, reopened]
    paths:
      - "services/**"
      - "infra/**"
      - "migrations/**"
      - ".github/workflows/dev-pr-stg-apply.yml"
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: pr-stg-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  # --- naming / imagens ---
  ECR_REGISTRY: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}

  TAG_PREFIX: pr-${{ github.event.pull_request.number || 'manual-test' }}
  IMAGE_TAG_INTER:  pr-${{ github.event.pull_request.number }}-inter
  IMAGE_TAG_AGENT:  pr-${{ github.event.pull_request.number }}-agent
  IMAGE_TAG_PRINC:  pr-${{ github.event.pull_request.number }}-principal

  # --- Terraform backend (remoto j√° existente) ---
  TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}          
  TF_STATE_KEY_INFRA: apprunner/pr-${{ github.event.pull_request.number }}/terraform.tfstate    
  TF_STATE_LOCK_TABLE: ${{ vars.TF_STATE_LOCK_TABLE }}  

  # --- NAME PREFIX por PR ---
  NAME_PREFIX: ura-chatbot-ia-pr-${{ github.event.pull_request.number || 'manual' }}

  # --- TF_VAR_* ---
  TF_VAR_region: ${{ vars.AWS_REGION }}
  TF_VAR_name_prefix: ura-chatbot-ia-pr-${{ github.event.pull_request.number || 'manual' }}
  TF_VAR_account_id: ${{ vars.AWS_ACCOUNT_ID }}
  TF_VAR_ecr_repository: ${{ vars.ECR_REPOSITORY }}
  TF_VAR_image_tag_api_intermediaria: pr-${{ github.event.pull_request.number }}-inter
  TF_VAR_image_tag_api_agente:        pr-${{ github.event.pull_request.number }}-agent
  TF_VAR_image_tag_api_principal:     pr-${{ github.event.pull_request.number }}-principal
  TF_VAR_rds_db_name: app_stg

  # üëá ajuste aqui, alinhando com o variables.tf e com seus SECRETS do GitHub
  TF_VAR_API_PRINCIPAL_API_KEY:      ${{ secrets.API_PRINCIPAL_API_KEY_STG }}
  TF_VAR_API_PRINCIPAL_SECRET_KEY:   ${{ secrets.API_PRINCIPAL_SECRET_KEY_STG }}
  TF_VAR_WHASTAPP_CLIENT_TOKEN:      ${{ secrets.WHASTAPP_CLIENT_TOKEN_STG }}

  TF_VAR_APP_SECURITY_ENCRYPTION_KEY:    ${{ secrets.APP_SECURITY_ENCRYPTION_KEY_STG }}
  TF_VAR_URA_CHATBOT_IA_SECRET_KEY:      ${{ secrets.API_PRINCIPAL_SECRET_KEY_STG }}
  

  # --- diret√≥rios ---
  SERVICE_INTER_PATH: services/api-intermediaria
  SERVICE_AGENT_PATH: services/api-agente
  SERVICE_PRINC_PATH: services/api-principal
  INFRA_DIR: infra
  MIGRATIONS_DIR: migrations/sql


jobs:
  build-infra-migrate:
    name: Build images ‚Üí Terraform apply ‚Üí Flyway migrate
    runs-on: ubuntu-latest
    environment: development
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_STG }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Buildx (docker-container)
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver: docker-container

      # ---------- Build & Push ----------
      - name: Build & Push - api-intermediaria
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_INTER_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_INTER }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-inter
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-inter,mode=max
          build-args: |
            RUN_TESTS=false

      - name: Build & Push - api-agente
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_AGENT_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_AGENT }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-agent
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-agent,mode=max
          build-args: |
            RUN_TESTS=false

      - name: Build & Push - api-principal
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.SERVICE_PRINC_PATH }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG_PRINC }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-principal
          cache-to:   type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:cache-principal,mode=max
          build-args: |
            RUN_TESTS=false

      # 2) (opcional) Garantir a tabela de lock do Terraform
      - name: Ensure DynamoDB lock table exists
        run: |
          if ! aws dynamodb describe-table --table-name "${TF_STATE_LOCK_TABLE}" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "${TF_STATE_LOCK_TABLE}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "${TF_STATE_LOCK_TABLE}"
          fi

      # 3) Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8

      # 4) Terraform init (backend com S3+DynamoDB)
      - name: Terraform init (reconfigure backend with lock)
        working-directory: ${{ env.INFRA_DIR }}
        run: |
          terraform init -input=false -upgrade -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY_INFRA}" \
            -backend-config="region=${{ vars.AWS_REGION }}" \
            -backend-config="dynamodb_table=${TF_STATE_LOCK_TABLE}" \
            -backend-config="encrypt=true"


            # ---------- Terraform PASSO 1: s√≥ infra (sem servi√ßos) ----------
      - name: Terraform plan (infra only)
        working-directory: ${{ env.INFRA_DIR }}
        env:
          TF_VAR_create_services: "false"
          TF_LOG: INFO
          TF_LOG_PATH: terraform-plan.log
        run: terraform plan -input=false -no-color -lock-timeout=300s -parallelism=10 -out=tfplan_infra

      - name: Upload TF plan log
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: tf-plan-log
          path: infra/terraform-plan.log


      - name: Terraform apply (infra only)
        working-directory: ${{ env.INFRA_DIR }}
        env:
          TF_VAR_create_services: "false"
        run: terraform apply -auto-approve tfplan_infra

      # ---------- Flyway: roda migra√ß√µes ap√≥s RDS pronto ----------
      - name: Install tools (jq)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get DB creds from Terraform Output
        working-directory: ${{ env.INFRA_DIR }}
        run: |
          # Pega os valores brutos (-raw) do output do Terraform
          DB_ENDPOINT=$(terraform output -raw rds_mysql_endpoint)
          DB_USER=$(terraform output -raw rds_username)
          DB_PASS=$(terraform output -raw rds_password)
          
          # Monta a URL JDBC para o Flyway
          echo "FLYWAY_URL=jdbc:mysql://${DB_ENDPOINT}/${{ env.TF_VAR_rds_db_name }}" >> $GITHUB_ENV
          echo "FLYWAY_USER=${DB_USER}" >> $GITHUB_ENV
          
          # Mascara a senha no log do GitHub Actions por seguran√ßa
          echo "::add-mask::${DB_PASS}"
          echo "FLYWAY_PASSWORD=${DB_PASS}" >> $GITHUB_ENV

      - name: Run Flyway migrate (Docker)
        run: |
          docker run --rm \
            -v "${{ github.workspace }}/migrations/flyway:/flyway/sql" \
            flyway/flyway:latest \
            -url="${FLYWAY_URL}" \
            -user="${FLYWAY_USER}" \
            -password="${FLYWAY_PASSWORD}" \
            -connectRetries=30 \
            migrate

      # ---------- Terraform PASSO 2: agora cria os servi√ßos ----------
      - name: Terraform plan (services on)
        working-directory: ${{ env.INFRA_DIR }}
        env:
          TF_VAR_create_services: "true"
        run: terraform plan -out=tfplan_services

      - name: Terraform apply (services on)
        working-directory: ${{ env.INFRA_DIR }}
        env:
          TF_VAR_create_services: "true"
        run: terraform apply -auto-approve tfplan_services
